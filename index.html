<!DOCTYPE html>
<html>
 
<head>
  <meta charset="utf-8">
  <title></title>
  <script src="resources\js\apexcharts.min.js"></script>
  <style>
	

body{
  font-size:26px;

  font-family: 'Avenir', sans-serif;
  background:white;
  width: 98%;
  margin: 0 auto;
}
h1{text-align: center;}
tspan{
  font-size:.4em;
 }

#box1
{
  margin: 0 auto;
   position: relative;
   background-color:#313946; 
   width:100% ;
   height:390px;
   display: flex;
   justify-content: space-between;
  
  border-radius: 5px;
  padding-top: 30px;
  padding-bottom: 40px;
}
#box3
{
   margin-left: 0%;
   position: relative;
   background-color:#313946; 
   width:100% ;
   height:440px;
   display: flex;
   justify-content: space-between;
   border-radius: 5px;
   padding-top: 20px;
   padding-bottom: 20px;
   margin-top: 30px;
}
#box2
{
  margin: 0 auto;
   position: relative;
   background-color:#313946; 
   width:92% ;
   height:725px;
   display: flex;
   justify-content: space-between;

  
  border-radius: 5px;
  padding-top: 20px;
  padding-bottom: 20px;
}
#gg_0,#ggphs_0,#gg7{
  
margin-top: 50px;
  margin-left: 0;
  width:300px; 
  height:300px;
  background-color:blac;

}
#gg_1,#ggphs_1{
  margin-top: 50px;
  width:300px;
  height:300px;

  text-align: center; 
  background-color:blac;
}

#gg_2,#ggphs_2{
 
   
  margin-top: 50px;
 margin-right:0%;
  width:300px;
  height:300px;
  background-color:blac;
 
}

.dial{
   fill:transparent;
  stroke-linecap:"round";
  stroke-dasharray:.16em,.27em;
  r:5em; 
}

#dial_bg{
  stroke:green;
  stroke-width:.8em;
}
#dial{
  stroke-width:2em; 
}

.point{
  fill:cyan;
  r: .25em;

}

.limite{
  fill:orange;
  r: .25em;

}

#needles{
  transform: translateY(-.5em);
  r: 1.8em;

}
.smooth{/* valutext*/
  transition: all .5s linear;
 /*transition:  all 1s cubic-bezier(0.01,0.02,0.4,  1);
 */
 font-size:2.5em;
  font-weight:200;
  fill:white;
}

.lbltext{
  font-family:'Lato';
  font-size:2em;
  font-weight:300;
  fill:white;
  
}

.gauge-name {

  font-size: 20px;
  position: absolute;
  color:white ;
  display: block;}

/* Set individual colors for the names */
#name_0 {  }
#name_1 {   }
#name_2 {  }

.popup {
    width: 100%;
  display: none; 
  position: fixed;
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  border-radius: 10px 10px;
  padding: 12px 12px 12px 12px;
  z-index: 9999; 
  color: white;
}
.namebox2{ 
  flex: 1; 
 text-align: center;
 color:white;
 padding: 15px;
 font-size: 35px;




}
.namebox_main2{

  position: absolute; 
  top: 400px;
  width: 100%;
  display: flex; 
  justify-content: space-between; 
  align-items: flex-end;

  }
#overlay {
  position: fixed;
  display: none;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0,0,0,80%);
  z-index: 9998;
  cursor: pointer;
}
.namebox{ flex: 1; 
 
   padding: 5px;
   text-align: center;
   color:white;
   padding: 20px;
   font-size: 35px;
  
}
.namebox_main{
  position: absolute; 
  bottom: 5px;
  width: 100%;
  display: flex; 
  justify-content: space-between; 
  align-items: flex-end;


  }

  #top_box_main{

    position: absolute;
     top: 0;
      width: 100%;
        justify-content: space-between;
      align-items: flex-end;
       
       border: 1px solid gray;
  
        color:rgb(255, 255, 255) ;
        
            
        
  }
  .top_box{

    padding: 5px;
   text-align: right;
   color:white;
   padding: 20px;
   font-size: 35px;
   font-size: 25px;
  
  }
  .namebox_main4{
  position: relative; 
  bottom: 250px;
  width: 90%;
margin: 0 auto;

}



  .boxa{
 /* Add border to each div */
  padding: 10px; /* Add some padding inside the div */
 /* Space between divs */
  text-align: center; /* Center the text inside each div */
  bottom: 220px;
  width: 80%;

}

table, td {
  border:1px solid white;
  margin-left: auto;
  margin-right: auto;
  padding: 10px;
}
th{background-color: white;
color:black;
padding: 10px;}
</style>
</head>
<div>
  <h1> Smart Energy Dashboard</h1>
 
  <div id='box1'>
    <div id="top_box_main" ><div class="top_box">01H :30M :45S</div></div>

    <div class="namebox_main">
      <div class="namebox" >Voltage </div>
      <div class="namebox">Current  </div>
      <div class="namebox" >Power</div>
    </div>
    
    
    
  </div>
  <div id='box3'>
    <div id="top_box_main" ><div class="top_box">Import & Export Active Power</div></div>
    <div id="c" style="width: 95%; position: absolute; top: 100px; " ></div>

   
    </div>





  
  <div id="popup" class="popup"  style="display:none;">
 
  <div id='box2'></div>
  <div class="namebox_main2">
    <div class="namebox2" >Phase 01 </div>
    <div class="namebox2">Phase 02  </div>
    <div class="namebox2" >Phase 03</div>
  </div>
  <div class="namebox_main4">
 <table class="boxa" style="border: 1px;">
  <tr>
    <th>Phase</th>
    <th id="unit">229.234</th>
  </tr>
  <tr>
    <td>Phase 01</td>
    <td id="v_0">229.234</td>
  </tr>
  <tr>
    <td>Phase 02</td>
    <td id="v_1">231.04</td>
  </tr>
  <tr>
    <td>Phase 03</td>
    <td id="v_2">225.90</td>
  </tr>
 </table>
  
  </div>
</div>


<div id="overlay" onclick="hidePopup()"></div>
  <script>

        var options = {
          series: [{
          data: [4000, 3000]
        }],
          chart: {
          type: 'bar',
          height: 320
        },
        plotOptions: {
          bar: {
            barHeight: '70%',
            distributed: true,
            horizontal: true,
            dataLabels: {
              position: 'bottom'
            },
          }
        },
        colors: ['#00CD8D', '#00FFFF'
        ],
        dataLabels: {
          enabled: true,
          textAnchor: 'start',
          style: {
            fontSize: '25px',
            colors: ['#fff']
          },
          formatter: function (val, opt) {
            return opt.w.globals.labels[opt.dataPointIndex] + ":  " + val +' W'
          },
          offsetX: 0,
          dropShadow: {
            enabled: true
          }
        },
        stroke: {
          width: 1,
          colors: ['#fff']
        },
        xaxis: {
          categories: ['Import', 'Export'
          ],
          labels: {
            show: true,
            style: {
            fontSize:'40px',
            colors: ['white'],
                      },
            
          offsetY: 15,
          },

        },



        yaxis: {
          labels: {
            show: false
          }
        },
        title: {
            text: 'Custom DataLabels',
            align: 'center',
            floating: true
        },
        subtitle: {
            text: 'Category Names as DataLabels inside bars',
            align: 'center',
        },
        tooltip: {
          theme: 'dark',
          x: {
            show: false
          },
          y: {
            title: {
              formatter: function () {
                return ''
              }
            }
          }
        }
        
        };

        var chart = new ApexCharts(document.querySelector("#c"), options);
        chart.render();
      
var payload=[
   {		
  "ts": [253961],		
  "id": [1],		
  "volt": [229.92,231.29,225.95],		//
  "curr": [4.42,5.07, 21.53],		//
  "curr_sum": [31.02],		//
  "pow": [975.44,1161.38,4835.45],		//
  "pow_tot": [6972.27],		//
  "v_am": [995.44,1165.54,4845.08],		
  "v_am_tot": [6998.27],		
  "v_am_re": [-198.62,-98.78,305.31],		
  "v_am_re_tot": [0.00],		
  "pf": [0.98, 1.00, 1.00],		
  "pf_tot": [1.00],		
  "pa": [-8.46, -3.89, 4.67],		
  "pa_tot": [-2.56],		
  "volt_avg": [229.08],	//	
  "curr_avg": [10.34],		
  "freq": [50.20],		
  "im_ac_en": [102039.90],		
  "ex_ac_en": [54.14],		
  "im_re_en": [6033.00],		
  "ex_re_en": [11615.90],		
  "tot_sys_pow_dem": [8474.51],		
  "max_tot_sys_pow": [15615.83],		
  "n_curr_dem": [11.47],		
  "max_n_curr_dem": [29.18],		
  "n_curr": [16.74],		
  "max_phs_curr_dem": [23.72, 36.41, 38.07]		
},

{
  "ts":[253961],
  "id": [2],
  "volt": [229.92],
  "curr": [4.42],
  "pow": [975.44],
  "ac_ap": [995.44],
  "re_ap": [-198.62],
  "pow_fac": [0.98],
  "phs_ang": [-8.46],
  "ferq": [50.20],
  "im_ac_en": [102039.90],
  "ex_ac_en": [54.14],
  "tot_ac_en": [102094.04],
  "im_re_en": [6033.00],
  "ex_re_en": [11615.90],
  "tot_re_en": [17648.90]
}
];

var topic="node/em3/n2b/16261432/dev/1";
var em="em3";
var gauge_3phs = [
  { value: payload[0].volt_avg[0], name: "Voltage Avareage (V)" },  
  { value: payload[0].curr_sum[0], name: "Current Total (A)" },  
  { value: payload[0].pow_tot[0], name: "PowerTotal (W)" }      
];
var gauge_1phs = [
  { value: payload[1].volt[0], name: "Voltage (V)"},  
  { value: payload[1].curr[0], name: "Current (A)"},  
  { value: payload[1].pow[0], name: "Power (W)" }      
];


function  addPath(gr,sx,sy,ex,ey,g)

{
  newpath = document.createElementNS('http://www.w3.org/2000/svg',"path"); 
  
  sx+=150;
  sy+=150;
  ex+=150;
  ey+=150;
 // stroke=color_value;
newpath.setAttributeNS(null, "id", "pathIdD");  
newpath.setAttributeNS(null, "d", "M "+sx+" "+sy+" L "+ex+" "+ey);  
newpath.setAttributeNS(null, "stroke", eval(g.color)); 
newpath.setAttributeNS(null, "stroke-width", eval(g.lineWidth));  
newpath.setAttributeNS(null, "opacity", 1);  
newpath.setAttributeNS(null, "fill", "none");

document.getElementById(gr).appendChild(newpath);


}

var gauge =[
      {
        ////////  KM/H  /////////
        radius:26.5,//radio del medidor
        angle:270,// angulo total del medidor
        start:155,// angulo de inicio del medidor
        divs:50,// divisiones
        value:467.09,// valor inicial
        limit:0,// valor del limite (escala secundaria)
        min:0,// valor mínimo del medidor
        max:7000,// valor máximo (fondo de escala) 
        color:"'cyan'",// color del medidor(eval);"'cyan'"
        alertColor:"'red'",// color del medidor(eval);
        limitColor:"'orange'",// color del medidor(eval);
        units:"'v'",// leyenda abajo del valor (eval)
        lineWidth:'pos/8',// ancho del segmento
        lineSize:6,// largo del segmento
        lineOffset:0,
        needleStart:0,
        needleEnd:-7,
        pointPos: -4,
        refresh:10,
        pointColor:"'green'",

        scale:{
          lineWidth:'pos/8',
          lineSize:2,
          color:"'white'",
          lineOffset:0,

        },

        scaleOver:{
          lineWidth:'pos/8',
          lineSize:6,
          color:"'red'",
          lineOffset:0



        },

          scaleLimit:{
          lineWidth:'pos/8', 
          lineSize:6,
          color:"'orange'",
          needleStart:0,
          needleEnd:-6,
          pointPos:9,
          lineOffset:0


        }
        
      },
      {  ///// TEMP ////
        radius:28,//radio del medidor
        angle:360,// angulo total del medidor
        start:270,// angulo de inicio del medidor
        divs:50,// divisiones
        value:500,// valor inicial
        limit:0,// valor del limite (escala secundaria)
        min:0,// valor mínimo del medidor
        max:5020,// valor máximo (fondo de escala) 
        color:"'rgb('+(pos*4)+','+(255-(pos*2))+','+(255-(pos*4))+')'",// color del medidor(eval);
        alertColor:"'red'",// color del medidor(eval);
        limitColor:"'yellow'",// color del medidor(eval);
        units:"'A'",// leyenda abajo del valor (eval)
        lineWidth:6,// ancho del segmento
        lineSize:4,// largo del segmento
        lineOffset:0,
        needleStart:0,
        needleEnd:-4,
        pointPos: -3,
        pointColor:"'magenta'",
        refresh:100,
        scale:{
          lineWidth:1,
          lineSize:1,
          color:"'white'",
          lineOffset:1,

        },

          scaleLimit:{
          lineWidth:3,
          lineSize:3,
          color:"'orange'",
          needleStart:-3,
          needleEnd:2,
          pointPos:5,
          lineOffset:0,


        }
        
      },      
  
  
  ]
;
var step=1;
var sang;
var cang;
var m=4;
var cnt=0;
var active=0;
var pos=0;
var valuePrint=0;
/*var limiteq=0;
 var pointq= 0;
  var valtextq =0;
  var lbltextq=0;
  var gr=0;*/
 // var valtextq =0;
function drawG(value1, active, limite, point, valtext, lbltext, grq)
{
  

  var limiteq=limite;
  var pointq= point;
  var valtextq =valtext;
  var lbltextq=lbltext;
  var gr=0;
  var g = gauge[active];
  var value= eval(g.value);
  var valuePrint=value;
  console.log('my',value);
  var gr = grq;
  var scaleLimit = (g.scaleLimit) ? g.scaleLimit:g;                 
  var scaleOver = (g.scaleOver) ? g.scaleOver:g;                 
  var scale = (g.scale) ? g.scale:g;  
  
  

  if(g.angle<=0)g.angle=180;
  value = value/(g.max/g.divs);
  var limit=0;
  if(g.limit>0)limit= Math.floor(g.limit / (g.max/g.divs));
  var i; 
  step=g.angle/g.divs;
  document.getElementById(gr).innerHTML="init";
  pos=0;
  var degree = (g.start)+90+(step*cnt);
  var limitdegree = (g.start)+90+(step*limit);
         i= g.start;
         while (i<=(g.angle+g.start)) {
           ang= i * Math.PI / 180;
           sang=Math.cos(ang);
           cang=Math.sin(ang);
           sx=sang*(g.radius+g.lineSize)*m;
           sy=cang*(g.radius+g.lineSize)*m; 
           ex=sang*g.radius*m;
           ey=cang*g.radius*m;
           
           if(pos<cnt){// medidor
             
             
         
              if(limit>0 && pos>limit){
                
                  sx=sang*(g.radius+scaleOver.lineSize+scaleOver.lineOffset)*m;
                  sy=cang*(g.radius+scaleOver.lineSize+scaleOver.lineOffset)*m; 
                  ex=sang*(g.radius+scaleOver.lineOffset)*m;
                  ey=cang*(g.radius+scaleOver.lineOffset)*m;

                 
               addPath(gr,sx,sy,ex,ey,scaleOver);
             }else{
                addPath(gr,sx,sy,ex,ey,g);
            }


           }else
           if(pos>cnt)// limite (orange) o escala (white)
             {       
               
               
               
                      if(limit>0 && pos<limit) {//limite
                        
           sx=sang*(g.radius+scaleLimit.lineOffset+scaleLimit.lineSize)*m;
           sy=cang*(g.radius+scaleLimit.lineOffset+scaleLimit.lineSize)*m; 
           ex=sang*(g.radius+scaleLimit.lineOffset)*m;
           ey=cang*(g.radius+scaleLimit.lineOffset)*m;    
              addPath(gr,sx,sy,ex,ey,scaleLimit);
                             
                

                      }
                      else
                      if(limit==0 || pos>limit){//escala o escalaover
                           
                        sx=sang*(g.radius+scale.lineSize+scale.lineOffset)*m;
                        sy=cang*(g.radius+scale.lineSize+scale.lineOffset)*m; 
                        ex=sang*(g.radius+scale.lineOffset)*m;
                        ey=cang*(g.radius+scale.lineOffset)*m;         
                        addPath(gr,sx,sy,ex,ey,scale);




                      }
             
               
               else{// scaleLmit needle
                 
                 if(limit>0)
                   {
                 lsx=sang*(g.radius+scaleLimit.lineSize+scaleLimit.needleStart)*m;
                 lsy=cang*(g.radius+scaleLimit.lineSize+scaleLimit.needleStart)*m;
                 lex=sang*(g.radius+scaleLimit.lineSize+scaleLimit.needleEnd)*m;
                 ley=cang*(g.radius+scaleLimit.lineSize+scaleLimit.needleEnd)*m;
            
                   }

 

               }

             }
           else
             { //needle 
               
                sx=sang*(g.radius+g.lineSize+g.needleStart)*m;
                 sy=cang*(g.radius+g.lineSize+g.needleStart)*m;
                 ex=sang*(g.radius+g.lineSize+g.needleEnd)*m;
                 ey=cang*(g.radius+g.lineSize+g.needleEnd)*m;
                    addPath(gr,sx,sy,ex,ey,g);

             }
           
   
i+=step;
  pos++;
    
     
    }
   
 if(limit>0)
   {
addPath(gr,lsx,lsy,lex,ley,scaleLimit);
       limiteq.style.display= "inherit";



limiteq.style.transform  = `rotate(${limitdegree}deg) translateY(-${(g.radius+scaleLimit.pointPos)*m}px) rotate(-${limitdegree}deg) `;

   }else
     {
       limiteq.style.display= "none";
     }
 pointq.style.transform  = `rotate(${degree}deg) translateY(-${(g.radius+g.pointPos)*m}px) rotate(-${degree}deg) `;

 

  
  if(limit>0 && cnt>limit){
    valtextq.style.fill=eval(g.alertColor);
  }else if(limit>0 && cnt==limit){
    valtextq.style.fill=eval(g.limitColor);
  }else
    {
      valtextq.style.fill=eval(g.color);
    }
  
 
  
  // ((value/(pos*cnt) *100)/10)
  lbltextq.textContent=eval(g.units);
//    lbltext.textContent=value;
  
    if(cnt<value){
        cnt++;
        if(cnt>value){
         setValueText(valuePrint);
        // console.log('valueInt-- ',cnt );
          return;
        }
      }else
     if(cnt>value){
        cnt--;
        if(cnt<value){
        setValueText(valuePrint);
       //console.log('valueInt-- ',value );
          return;
        }
      }
    else {
          setValueText(valuePrint);
    //    console.log('valueInt-- ',value );
      return;
    }




  var rfrsh = 10;
  if(g.refresh)rfrsh=g.refresh;
      setTimeout(function(){
      
      console.log('valueInt55-- ',g.refresh );
      },rfrsh);
    drawG(value, active, limite, point, valtext, lbltext, grq);
      
  
 function setValueText(v)
{
  var valueInt =  Math.trunc(v);
 
 // var valueDec = Math.trunc((v - valueInt)*10);
  valtext.innerHTML= valueInt ;

}

}

switch(em) {
  case "em3":  
 var passGauge = (i) =>`

  <svg id="gg_${i}" onclick="display_phs(this.id)">
    <g id="g_${i}"></g>
    <g id="g2">
      <text id="valtext_${i}" class="smooth" x="50%" y="55%" text-anchor="middle" alignment-baseline="bottom"></text>
      <text id="lbltext_${i}" class="lbltext" x="50%" y="63%" text-anchor="middle" alignment-baseline="central"></text>
      <circle id="limite_${i}" class='limite' cx="50%" cy="50%" />
      <circle id="point_${i}" class="point" cx="50%" cy="50%" />
      <text id="limitText_${i}" x="50%" y="50%" text-anchor="middle" alignment-baseline="central"></text>
      
    </g>  
  </svg>
`;

for (let i = 0; i < gauge_3phs.length; i++) {
  try {

     if( i == 0)
     {
      var active = 1;
      gauge[active].max=250;
      gauge[active].units="'V'"
     }

     else if(i == 1)
     {
      var active = 1;
      gauge[active].max=gauge_3phs[i].value+ 8;
      gauge[active].angle=270;
      gauge[active].start=180;
      gauge[active].color="'yellow'";
      gauge[active].units="'A'"
     }

     else if( i== 2)
     {
      var active = 0; 
      gauge[active].max=(gauge_3phs[i].value + 500);
      gauge[active].limit=(6000);
      gauge[active].units="'W'"
     }

      const template = passGauge(i);
      document.getElementById('box1').insertAdjacentHTML('beforeend', template);
      console.log(i);

     
      var limite = document.getElementById('limite_' + i);
      var point = document.getElementById('point_' + i);
      var valtext = document.getElementById('valtext_' + i);
      var lbltext = document.getElementById('lbltext_' + i);
      var grq = 'g_' + i;  

      gauge[active].value = gauge_3phs[i].value;
      drawG(gauge_3phs[i].value, active, limite, point, valtext, lbltext, grq);

  } catch (error) {
    console.error('Error drawing gauge for index ' + i + ':', error);
  }
}


    break;
  case "em":
   
  
 var passGauge = (i) =>`
     <p id="name_${i}" class="gauge-name">${gauge_1phs[i].name}</p> <!-- Changed to Phase 01, Phase 02, etc. -->

  <svg id="gg_${i}">
    <g id="g_${i}"></g>
    <g id="g2">
      <text id="valtext_${i}" class="smooth" x="50%" y="55%" text-anchor="middle" alignment-baseline="bottom"></text>
      <text id="lbltext_${i}" class="lbltext" x="50%" y="63%" text-anchor="middle" alignment-baseline="central"></text>
      <circle id="limite_${i}" class='limite' cx="50%" cy="50%" />
      <circle id="point_${i}" class="point" cx="50%" cy="50%" />
      <text id="limitText_${i}" x="50%" y="50%" text-anchor="middle" alignment-baseline="central"></text>
    </g>  
  </svg>
`;
for (let i = 0; i < gauge_1phs.length; i++) {
  try {

     if( i == 0)
     {
      var active = 1;
      gauge[active].max=250;
      gauge[active].units="'V'"
     }
     else if(i == 1)
     {
      var active = 1;
      gauge[active].max=gauge_1phs[i].value+ 5;
      gauge[active].angle=270;
      gauge[active].start=180;
      gauge[active].color="'yellow'";
      gauge[active].units="'A'"
     }
     else if( i== 2)
     {
      var active = 0; 
      gauge[active].max=(gauge_1phs[i].value + 50);
      gauge[active].limit=(800);
        gauge[active].units="'W'"
     }
  
   
      const template = passGauge(i);
      document.getElementById('box1').insertAdjacentHTML('beforeend', template);
      console.log(i);

      // Correctly retrieve elements by constructing the IDs dynamically
      var limite = document.getElementById('limite_' + i);
      var point = document.getElementById('point_' + i);
      var valtext = document.getElementById('valtext_' + i);
      var lbltext = document.getElementById('lbltext_' + i);
      var grq = 'g_' + i; 

      gauge[active].value = gauge_1phs[i].value;
      drawG(gauge_1phs[i].value, active, limite, point, valtext, lbltext, grq);

  } catch (error) {
    console.error('Error drawing gauge for index ' + i + ':', error);
  }
}

    break;
  default:

}



function display_phs(id)
{
//var val=0;

  document.getElementById('box2').innerHTML = '';
  
  document.getElementById('popup').style.display='block';
  document.getElementById('overlay').style.display='block';
   //document.getElementById('box2').innerHTML=id;
   console.log(id);
   var passGauge2 = (i) =>`

  <svg id="ggphs_${i}">
    <g id="gphs_${i}"></g>
    <g id="g2">
      <text id="valtextphs_${i}" class="smooth" x="50%" y="55%" text-anchor="middle" alignment-baseline="bottom"></text>
      <text id="lbltextphs_${i}" class="lbltext" x="50%" y="63%" text-anchor="middle" alignment-baseline="central"></text>
      <circle id="limitephs_${i}" class='limite' cx="50%" cy="50%" />
      <circle id="pointphs_${i}" class="point" cx="50%" cy="50%" />
      <text id="limitTextphs_${i}" x="50%" y="50%" text-anchor="middle" alignment-baseline="central"></text>
    </g>  
  </svg>

`;

for (let i = 0; i < gauge_3phs.length; i++) {

  const template = passGauge2(i);
      document.getElementById('box2').insertAdjacentHTML('beforeend', template);
      console.log(i);

      
      var limite = document.getElementById('limitephs_' + i);
      var point = document.getElementById('pointphs_' + i);
      var valtext = document.getElementById('valtextphs_' + i);
      var lbltext = document.getElementById('lbltextphs_' + i);
      var grq = 'gphs_' + i;  
    
      if(id == 'gg_0')
     {
      var active = 1;
      gauge[active].max=250;
      gauge[active].units="'V'"
      gauge[active].angle=360;
      gauge[active].start=270;
      gauge[active].color="'rgb('+(pos*4)+','+(255-(pos*2))+','+(255-(pos*4))+')'";
      var val = payload[0].volt[i];
      //console.log(val)
      unit.innerHTML='V';
      document.getElementById("v_"+i).innerHTML=val;
     }
     else if(id == 'gg_1')
     {
      var active = 1;
      gauge[active].max=(30);
      gauge[active].angle=270;
      gauge[active].start=180;
      gauge[active].color="'yellow'";
      gauge[active].units="'A'";
      var val = payload[0].curr[i];
      unit.innerHTML='A';
      document.getElementById("v_"+i).innerHTML=val;
     }
     else if( id == 'gg_2')
     {
      var active = 0; 
      gauge[active].max=(5000);
      gauge[active].limit=(4000);
      gauge[active].units="'W'";
      var val = payload[0].pow[i];
      unit.innerHTML='W';
    document.getElementById("v_"+i).innerHTML=val;
     } 
      
 
    
      gauge[active].value = val;
      drawG(val, active, limite, point, valtext, lbltext, grq);
}


/*for (let i = 0; i < gauge_3phs.length; i++) {
  try {

     if( i == 0)
     {
      var active = 1;
      gauge[active].max=250;
      gauge[active].units="'V'"
     }
     else if(i == 1)
     {
      var active = 1;
      gauge[active].max=gauge_3phs[i].value+ 50;
      gauge[active].angle=270;
      gauge[active].start=180;
      gauge[active].color="'yellow'";
      gauge[active].units="'A'"
     }
     else if( i== 2)
     {
      var active = 0; 
      gauge[active].max=(gauge_3phs[i].value + 500);
      gauge[active].limit=(6000);
      gauge[active].units="'W'"
     }
  
      const template = passGauge(i);
      document.getElementById('box2').insertAdjacentHTML('beforeend', template);
      console.log(i);

     
      var limite = document.getElementById('limite_' + i);
      var point = document.getElementById('point_' + i);
      var valtext = document.getElementById('valtext_' + i);
      var lbltext = document.getElementById('lbltext_' + i);
      var grq = 'g_' + i;  

      gauge[active].value = gauge_3phs[i].value;
      drawG(gauge_3phs[i].value, active, limite, point, valtext, lbltext, grq);

  } catch (error) {
    console.error('Error drawing gauge for index ' + i + ':', error);
  }
}*/

}


function hidePopup() {
    document.getElementById('popup').style.display = 'none';
    document.getElementById('overlay').style.display = 'none';
  }








  </script>
</body>
 
</html>