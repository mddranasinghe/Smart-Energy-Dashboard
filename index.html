<!DOCTYPE html>
<html>
 
<head>
  <meta charset="utf-8">
  <title></title>
  <script src="resources\js\apexcharts.min.js"></script>
  <script src="resources/js/paho.javascript-1.0.3/paho-mqtt-min.js"></script>
  <script src="resources/js/connection.js"></script>

  <style>
	

body{
  font-size:26px;

  font-family: 'Avenir', sans-serif;
  background:black;
  width: 98%;
  margin: 0 auto;
}
h1{text-align: center; color: white;}
tspan{
  font-size:.4em;
 }

#box1
{
  margin: 0 auto;
   position: relative;
   background-color:#313946; 
   width:100% ;
   height:390px;
   display: flex;
   justify-content: space-between;
  
  border-radius: 5px;
  padding-top: 30px;
  padding-bottom: 40px;
}
#box3,#box4
{
   margin-left: 0%;
   position: relative;
   background-color:#313946; 
   width:100% ;
   height:440px;
   display: flex;
   justify-content: space-between;
   border-radius: 5px;
   padding-top: 20px;
   padding-bottom: 20px;
   margin-top: 30px;
}
#box2
{
  margin: 0 auto;
   position: relative;
   background-color:#313946; 
   width:92% ;
   height:755px;
   display: flex;
   justify-content: space-between;

  
  border-radius: 5px;
  padding-top: 20px;
  padding-bottom: 20px;
}
#gg_0,#ggphs_0,#gg7{
  
margin-top: 50px;
  margin-left: 0;
  width:300px; 
  height:300px;
  background-color:blac;

}
#gg_1,#ggphs_1{
  margin-top: 50px;
  width:300px;
  height:300px;

  text-align: center; 
  background-color:blac;
}

#gg_2,#ggphs_2{
 
   
  margin-top: 50px;
 margin-right:0%;
  width:300px;
  height:300px;
  background-color:blac;
 
}

.dial{
   fill:transparent;
  stroke-linecap:"round";
  stroke-dasharray:.16em,.27em;
  r:5em; 
}

#dial_bg{
  stroke:green;
  stroke-width:.8em;
}
#dial{
  stroke-width:2em; 
}

.point{
  fill:cyan;
  r: .25em;

}

.limite{
  fill:orange;
  r: .25em;

}

#needles{
  transform: translateY(-.5em);
  r: 1.8em;

}
.smooth{/* valutext*/
  transition: all .5s linear;
 /*transition:  all 1s cubic-bezier(0.01,0.02,0.4,  1);
 */
 font-size:2.5em;
  font-weight:200;
  fill:white;
}

.lbltext{
  font-family:'Lato';
  font-size:2em;
  font-weight:300;
  fill:white;
  
}

.gauge-name {

  font-size: 20px;
  position: absolute;
  color:white ;
  display: block;}

/* Set individual colors for the names */


.popup {
    width: 100%;
  display: noe; 
  position: fixed;
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  border-radius: 10px 10px;
  padding: 12px 12px 12px 12px;
  z-index: 9999; 
  color: white;
  height: 755px;
}
.namebox2{ 
  flex: 1; 
 text-align: center;
 color:white;
 padding: 15px;
 font-size: 35px;





}
.namebox_main2{

  position: absolute; 
  top: 400px;
  width: 100%;
  display: flex; 
  justify-content: space-between; 
  align-items: flex-end;
  

  }
#overlay {
  position: fixed;
  display: none;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0,0,0,80%);
  z-index: 9998;
  cursor: pointer;
}
.namebox{ flex: 1; 
 
   padding: 5px;
   text-align: center;
   color:white;
   padding: 20px;
   font-size: 30px;

 
  
}
.namebox_main{
  position: absolute; 
  bottom: 5px;
  width: 100%;
  display: flex; 
  justify-content: space-between; 
  align-items: flex-end;


  }
  #n_0{ 
    text-align: left;
  padding-left: 50px;}

  #n_2{ 
    text-align: right;
  padding-right: 50px;}
  #top_box_main{

    position: absolute;
     top: 0;
      width: 100%;
        justify-content: space-between;
      align-items: flex-end;
       
      /* border: 1px solid gray;*/
  
        color:rgb(255, 255, 255) ;
        
            
        
  }
  .top_box{

    padding: 5px;
   text-align: right;
   color:white;
   padding: 20px;
   font-size: 35px;
   font-size: 25px;
  
  }
  .namebox_main4{
  position: relative; 
  bottom: 290px;
  width: 90%;
margin: 0 auto;

}



  .boxa{
 /* Add border to each div */
  padding: 10px; /* Add some padding inside the div */
 /* Space between divs */
  text-align: center; /* Center the text inside each div */
  bottom: 220px;
  width: 80%;

}

table, td {
  border:1px solid white;
  margin-left: auto;
  margin-right: auto;
  padding: 10px;
}
th{background-color: white;
color:black;
padding: 10px;}

.container{
width: 98%;
height: 80vh;
overflow: scroll;
border: 1px solid #ccc;margin: 0 auto;
}
.more_info{

  margin-bottom: 0%;
   position: fixed;
   background-color:#313946; 
   width:96% ;
   height:70px;
   display: flex;
margin: 0 auto;
   margin-top: 30px;
   left: 50%;
   transform: translateX(-50%); 
    border-radius: 10px;
    padding-top: 40px;
color: white;
    justify-content: center;
    font-size: 35px;
    
}
</style>
</head>
<div>
  <h1> Smart Energy Dashboard</h1>
 <div>


<div class="container">

  <div id='box1'></div>

  <div id='box3'>
    <div id="top_box_main" ><div class="top_box">Import & Export Active Power</div></div>
    <div id="c0" style="width: 95%; position: absolute; top: 100px; " ></div>  
  </div>

    <div id='box4'>
      <div id="top_box_main" ><div class="top_box">Import & Export Reactive Power</div></div>
      <div id="c1" style="width: 95%; position: absolute; top: 100px; " ></div>
  
     
    </div>
</div>

<div class="more_info">More Info</div>

  <div id="popup" class="popup"  style="display:none;">
 
  <div id='box2'></div>
  <div class="namebox_main2">
    <div class="namebox2" >Phase 01 </div>
    <div class="namebox2">Phase 02  </div>
    <div class="namebox2" >Phase 03</div>
  </div>
  <div class="namebox_main4">
 <table class="boxa" style="border: 1px;">
  <tr>
    <th>Phase</th>
    <th id="unit">229.234</th>
  </tr>
  <tr>
    <td>Phase 01</td>
    <td id="v_0">229.234</td>
  </tr>
  <tr>
    <td>Phase 02</td>
    <td id="v_1">231.04</td>
  </tr>
  <tr>
    <td>Phase 03</td>
    <td id="v_2">225.90</td>
  </tr>
 </table>
  
  </div>
</div>


<div id="overlay" onclick="hidePopup()"></div>
  <script>
    let payload,gauge_3phs,gauge_1phs=0, em="em3",id_gg;
let dq=0;

function connect(){//connect------------------------------------------------------------------
try{
client.connect({ onSuccess: onConnect,useSSL: mqttUseSSL,userName,password });
client.onConnectionLost = onConnectionLost;
client.onMessageArrived = onMessageArrived;

}catch{}}

function onConnect() {
try{
    console.log("onConnect");    
     client.subscribe('node/em3/#');
  //  sendCommandToDevice(publish_topic+"info","read");
  
}
catch{}
}

function sendCommandToDevice(topic,payload) {
  try{
    if (client.isConnected()) {
        console.log("sendCommandToDevice: " + topic + ", Payload: " + payload);
        var message = new Paho.MQTT.Message(payload);
        message.destinationName = topic;
        client.send(message);
    }}
    catch(error)
    {
      console.log(error);
    }
}

function onMessageArrived(message) {
  try {
    topic = message.destinationName;
    payloadTest = message.payloadString;
    
    console.log("Topic:", topic);
    topicsArray = topic.split("/");

    if (topicsArray[2] === 'list') {
    
     payload = typeof payloadTest === 'string' ? JSON.parse(payloadTest) : payloadTest;

      console.log("Payload:", payload);

      if (Array.isArray(payload) && payload.length > 0) {
        // 3-phase gauge data
         gauge_3phs = [
          { value: payload[0].volt_avg[0], name: "Voltage Average" },  
          { value: payload[0].curr_sum[0], name: "Current Total" },  
          { value: payload[0].pow_tot[0], name: "Power Total" }      
        ];

        // 1-phase gauge data
         gauge_1phs = [
          { value: payload[0].volt[0], name: "Voltage" },  
          { value: payload[0].curr[0], name: "Current" },  
          { value: payload[0].pow[0], name: "Power" }      
        ];

        Im_ex = [{im: payload[0].im_ac_en[0],ex: payload[0].ex_ac_en[0]},
                 {im: payload[0].im_re_en[0],ex: payload[0].ex_re_en[0]}
          ]

         //dq=payload[0].im_ac_en[0];
        
        dis(payload[0]); 
       display_phs(payload[0]);
   
      } else {
        console.error("Payload is not an array or is empty");
      }
    }
  } catch (error) {
    console.error("Error processing message:", error);
  }
}



function onConnectionLost(responseObject) {
  if (responseObject.errorCode !== 0) {
    console.log("onConnectionLost:"+responseObject.errorMessage);
 //   offlinestatus('offline');
  }
  
}
    


/*var payload=[
   {		
  "ts": [253961],		
  "id": [1],		
  "volt": [229.92,231.29,225.95],		//
  "curr": [4.42,5.07, 21.53],		//
  "curr_sum": [26.02],		//
  "pow": [975.44,1161.38,4835.45],		//
  "pow_tot": [6972.27],		//
  "v_am": [995.44,1165.54,4845.08],		
  "v_am_tot": [6998.27],		
  "v_am_re": [-198.62,-98.78,305.31],		
  "v_am_re_tot": [0.00],		
  "pf": [0.98, 1.00, 1.00],		
  "pf_tot": [1.00],		
  "pa": [-8.46, -3.89, 4.67],		
  "pa_tot": [-2.56],		
  "volt_avg": [229.08],	//	
  "curr_avg": [10.34],		
  "freq": [50.20],		
  "im_ac_en": [102039.90],		
  "ex_ac_en": [54.14],		
  "im_re_en": [6033.00],		
  "ex_re_en": [11615.90],		
  "tot_sys_pow_dem": [8474.51],		
  "max_tot_sys_pow": [15615.83],		
  "n_curr_dem": [11.47],		
  "max_n_curr_dem": [29.18],		
  "n_curr": [16.74],		
  "max_phs_curr_dem": [23.72, 36.41, 38.07]		
},

{
  "ts":[253961],
  "id": [2],
  "volt": [229.92],
  "curr": [4.42],
  "pow": [474.44],
  "ac_ap": [995.44],
  "re_ap": [-198.62],
  "pow_fac": [0.98],
  "phs_ang": [-8.46],
  "ferq": [50.20],
  "im_ac_en": [102039.90],
  "ex_ac_en": [54.14],
  "tot_ac_en": [102094.04],
  "im_re_en": [6033.00],
  "ex_re_en": [11615.90],
  "tot_re_en": [17648.90]
}
];*/

//var topic="node/em3/n2b/16261432/dev/1";




function  addPath(gr,sx,sy,ex,ey,g)

{
  newpath = document.createElementNS('http://www.w3.org/2000/svg',"path"); 
  
  sx+=150;
  sy+=150;
  ex+=150;
  ey+=150;
 // stroke=color_value;
newpath.setAttributeNS(null, "id", "pathIdD");  
newpath.setAttributeNS(null, "d", "M "+sx+" "+sy+" L "+ex+" "+ey);  
newpath.setAttributeNS(null, "stroke", eval(g.color)); 
newpath.setAttributeNS(null, "stroke-width", eval(g.lineWidth));  
newpath.setAttributeNS(null, "opacity", 1);  
newpath.setAttributeNS(null, "fill", "none");

document.getElementById(gr).appendChild(newpath);


}

var gauge =[
      {
        ////////  KM/H  /////////
        radius:26.5,//radio del medidor
        angle:270,// angulo total del medidor
        start:155,// angulo de inicio del medidor
        divs:50,// divisiones
        value:0,// valor inicial
        limit:400,// valor del limite (escala secundaria)
        min:0,// valor mínimo del medidor
        max:0,// valor máximo (fondo de escala) 
        color:"'cyan'",// color del medidor(eval);"'cyan'"
        alertColor:"'red'",// color del medidor(eval);
        limitColor:"'orange'",// color del medidor(eval);
        units:"'v'",// leyenda abajo del valor (eval)
        lineWidth:'pos/8',// ancho del segmento
        lineSize:6,// largo del segmento
        lineOffset:0,
        needleStart:0,
        needleEnd:-7,
        pointPos: -4,
        refresh:10,
        pointColor:"'green'",

        scale:{
          lineWidth:'pos/8',
          lineSize:6,
          color:"'white'",
          lineOffset:0,

        },

        scaleOver:{
          lineWidth:'pos/8',
          lineSize:6,
          color:"'red'",
          lineOffset:0



        },

          scaleLimit:{
         lineWidth:'pos/8', 
          lineSize:6,
          color:"'white'",
          needleStart:0,
          needleEnd:-6,
          pointPos:9,
          lineOffset:0


        }
        
      },
      {  ///// TEMP ////
        radius:28,//radio del medidor
        angle:360,// angulo total del medidor
        start:270,// angulo de inicio del medidor
        divs:50,// divisiones
        value:0,// valor inicial
        limit:0,// valor del limite (escala secundaria)
        min:0,// valor mínimo del medidor
        max:0,// valor máximo (fondo de escala) 
        color:"'rgb('+(pos*4)+','+(255-(pos*2))+','+(255-(pos*4))+')'",// color del medidor(eval);
        alertColor:"'red'",// color del medidor(eval);
        limitColor:"'yellow'",// color del medidor(eval);
        units:"'A'",// leyenda abajo del valor (eval)
        lineWidth:6,// ancho del segmento
        lineSize:4,// largo del segmento
        lineOffset:0,
        needleStart:0,
        needleEnd:-4,
        pointPos: -3,
        pointColor:"'magenta'",
        refresh:100,
        scale:{
          lineWidth:2,
          lineSize:3,
          color:"'white'",
          lineOffset:0,

        },

          scaleLimit:{
          lineWidth:3,
          lineSize:3,
          color:"'white'",
          needleStart:-3,
          needleEnd:2,
          pointPos:5,
          lineOffset:0,


        }
        
      },      
  
  
  ]
;
var step=1;
var sang;
var cang;
var m=4;
var cnt=0;
var active=0;
var pos=0;
var valuePrint=0;
function drawG(value1, active, limite, point, valtext, lbltext, grq)
{
  

  var limiteq=limite;
  var pointq= point;
  var valtextq =valtext;
  var lbltextq=lbltext;
  var gr=0;
  var g = gauge[active];
  var value= eval(g.value);
  var valuePrint=value;
  //console.log('my',value);
  var gr = grq;
  var scaleLimit = (g.scaleLimit) ? g.scaleLimit:g;                 
  var scaleOver = (g.scaleOver) ? g.scaleOver:g;                 
  var scale = (g.scale) ? g.scale:g;  
  
  

  if(g.angle<=0)g.angle=180;
  value = value/(g.max/g.divs);
  var limit=0;
  if(g.limit>0)limit= Math.floor(g.limit / (g.max/g.divs));
  var i; 
  step=g.angle/g.divs;
  document.getElementById(gr).innerHTML="init";
  pos=0;
  var degree = (g.start)+90+(step*cnt);
  var limitdegree = (g.start)+90+(step*limit);
         i= g.start;
         while (i<=(g.angle+g.start)) {
           ang= i * Math.PI / 180;
           sang=Math.cos(ang);
           cang=Math.sin(ang);
           sx=sang*(g.radius+g.lineSize)*m;
           sy=cang*(g.radius+g.lineSize)*m; 
           ex=sang*g.radius*m;
           ey=cang*g.radius*m;
           
           if(pos<cnt){// medidor
             
             
         
              if(limit>0 && pos>limit){
                
                  sx=sang*(g.radius+scaleOver.lineSize+scaleOver.lineOffset)*m;
                  sy=cang*(g.radius+scaleOver.lineSize+scaleOver.lineOffset)*m; 
                  ex=sang*(g.radius+scaleOver.lineOffset)*m;
                  ey=cang*(g.radius+scaleOver.lineOffset)*m;

                 
               addPath(gr,sx,sy,ex,ey,scaleOver);
             }else{
                addPath(gr,sx,sy,ex,ey,g);
            }


           }else
           if(pos>cnt)// limite (orange) o escala (white)
             {       
               
               
               
                      if(limit>0 && pos<limit) {//limite
                        
           sx=sang*(g.radius+scaleLimit.lineOffset+scaleLimit.lineSize)*m;
           sy=cang*(g.radius+scaleLimit.lineOffset+scaleLimit.lineSize)*m; 
           ex=sang*(g.radius+scaleLimit.lineOffset)*m;
           ey=cang*(g.radius+scaleLimit.lineOffset)*m;    
              addPath(gr,sx,sy,ex,ey,scaleLimit);
                             
                

                      }
                      else
                      if(limit==0 || pos>limit){//escala o escalaover
                           
                        sx=sang*(g.radius+scale.lineSize+scale.lineOffset)*m;
                        sy=cang*(g.radius+scale.lineSize+scale.lineOffset)*m; 
                        ex=sang*(g.radius+scale.lineOffset)*m;
                        ey=cang*(g.radius+scale.lineOffset)*m;         
                        addPath(gr,sx,sy,ex,ey,scale);




                      }
             
               
               else{// scaleLmit needle
                 
                 if(limit>0)
                   {
                 lsx=sang*(g.radius+scaleLimit.lineSize+scaleLimit.needleStart)*m;
                 lsy=cang*(g.radius+scaleLimit.lineSize+scaleLimit.needleStart)*m;
                 lex=sang*(g.radius+scaleLimit.lineSize+scaleLimit.needleEnd)*m;
                 ley=cang*(g.radius+scaleLimit.lineSize+scaleLimit.needleEnd)*m;
            
                   }

 

               }

             }
           else
             { //needle 
               
                sx=sang*(g.radius+g.lineSize+g.needleStart)*m;
                 sy=cang*(g.radius+g.lineSize+g.needleStart)*m;
                 ex=sang*(g.radius+g.lineSize+g.needleEnd)*m;
                 ey=cang*(g.radius+g.lineSize+g.needleEnd)*m;
                    addPath(gr,sx,sy,ex,ey,g);

             }
           
   
i+=step;
  pos++;
    
     
    }
   
 if(limit>0)
   {
addPath(gr,lsx,lsy,lex,ley,scaleLimit);
       limiteq.style.display= "inherit";



limiteq.style.transform  = `rotate(${limitdegree}deg) translateY(-${(g.radius+scaleLimit.pointPos)*m}px) rotate(-${limitdegree}deg) `;

   }else
     {
       limiteq.style.display= "none";
     }
 pointq.style.transform  = `rotate(${degree}deg) translateY(-${(g.radius+g.pointPos)*m}px) rotate(-${degree}deg) `;

 

  
  if(limit>0 && cnt>limit){
    valtextq.style.fill=eval(g.alertColor);
  }else if(limit>0 && cnt==limit){
    valtextq.style.fill=eval(g.limitColor);
  }else
    {
      valtextq.style.fill=eval(g.color);
    }
  
 
  
  // ((value/(pos*cnt) *100)/10)
  lbltextq.textContent=eval(g.units);
//    lbltext.textContent=value;
  
    if(cnt<value){
        cnt++;
        if(cnt>value){
         setValueText(valuePrint);
        // console.log('valueInt-- ',cnt );
          return;
        }
      }else
     if(cnt>value){
        cnt--;
        if(cnt<value){
        setValueText(valuePrint);
       //console.log('valueInt-- ',value );
          return;
        }
      }
    else {
          setValueText(valuePrint);
    //    console.log('valueInt-- ',value );
      return;
    }




  var rfrsh = 10;
  if(g.refresh)rfrsh=g.refresh;
      setTimeout(function(){
      
     // console.log('valueInt55-- ',g.refresh );
      },rfrsh);
    drawG(value, active, limite, point, valtext, lbltext, grq);
      
  
 function setValueText(v)
{
  var valueInt =  Math.trunc(v);
 
 // var valueDec = Math.trunc((v - valueInt)*10);
  valtext.innerHTML= valueInt ;

}



}


function dis(payload){
  document.getElementById('box1').innerHTML = '';
  document.getElementById('c1').innerHTML = '';
  document.getElementById('c0').innerHTML = '';

switch(em) {
    case "em3":  
  
 var passGauge = (i) =>`
  <div id="top_box_main" ><div class="top_box">01H :30M :45S</div></div>
    <div class="namebox_main">
      <div class="namebox" id="n_${i}">${gauge_3phs[i].name}</div>
   
   </div>
  <svg id="gg_${i}" onclick="popupWin(this.id)">
    <g id="g_${i}"></g>
    <g id="g2">
      <text id="valtext_${i}" class="smooth" x="50%" y="55%" text-anchor="middle" alignment-baseline="bottom"></text>
      <text id="lbltext_${i}" class="lbltext" x="50%" y="68%" text-anchor="middle" alignment-baseline="central"></text>
      <circle id="limite_${i}" class='limite' cx="50%" cy="50%" />
      <circle id="point_${i}" class="point" cx="50%" cy="50%" />
      <text id="limitText_${i}" x="50%" y="50%" text-anchor="middle" alignment-baseline="central"></text>
      
    </g>  
  </svg>
`;

for (let i = 0; i < gauge_3phs.length; i++) {
  try {
  
     if( i == 0)
     {
      var active = 1;
      gauge[active].max=250;
      gauge[active].units="'V'"
      gauge[active].limit=(0);
      gauge[active].angle=360;
      gauge[active].start=270;
      gauge[active].color="'rgb('+(pos*4)+','+(255-(pos*2))+','+(255-(pos*4))+')'";
     }

     else if(i == 1)
     {
      var active = 1;
      gauge[active].max=gauge_3phs[i].value+ 8;
      gauge[active].angle=270;
      gauge[active].start=180;
      gauge[active].color="'yellow'";
      gauge[active].units="'A'";
      gauge[active].limit=(0);
     }

     else if( i== 2)
     {
      var active = 1; 
      gauge[active].max=(7000);
      gauge[active].limit=(6000);
      gauge[active].units="'W'"
      gauge[active].color="'rgb(' + (pos * 4) + ',' + (255 - (pos * 2)) + ',' + (255 - (pos * 4)) + ')'";
     }

      const template = passGauge(i);
      document.getElementById('box1').insertAdjacentHTML('beforeend', template);
      console.log(i);

     
      var limite = document.getElementById('limite_' + i);
      var point = document.getElementById('point_' + i);
      var valtext = document.getElementById('valtext_' + i);
      var lbltext = document.getElementById('lbltext_' + i);
      var grq = 'g_' + i;  
     // var g= document.getElementById("n_"+i);
     //  g.innerHTML = gauge_3phs[i].name;
     // console.log(gauge_3phs[i].name);
      gauge[active].value = gauge_3phs[i].value;
      drawG(gauge_3phs[i].value, active, limite, point, valtext, lbltext, grq);

  } catch (error) {
    console.error('Error drawing gauge for index ' + i + ':', error);
  }
}


    break;
  case "em":
   
  
 var passGauge = (i) =>`

  <svg id="gg_${i}">
    <g id="g_${i}"></g>
    <g id="g2">
      <text id="valtext_${i}" class="smooth" x="50%" y="55%" text-anchor="middle" alignment-baseline="bottom"></text>
      <text id="lbltext_${i}" class="lbltext" x="50%" y="63%" text-anchor="middle" alignment-baseline="central"></text>
      <circle id="limite_${i}" class='limite' cx="50%" cy="50%" />
      <circle id="point_${i}" class="point" cx="50%" cy="50%" />
      <text id="limitText_${i}" x="50%" y="50%" text-anchor="middle" alignment-baseline="central"></text>
    </g>  
  </svg>
`;
for (let i = 0; i < gauge_1phs.length; i++) {
  try {

     if( i == 0)
     {
      var active = 1;
      gauge[active].max=250;
      gauge[active].units="'V'"
      gauge[active].limit=(0);
      gauge[active].angle=360;
      gauge[active].start=270;
      gauge[active].color="'rgb('+(pos*4)+','+(255-(pos*2))+','+(255-(pos*4))+')'";
     }
     else if(i == 1)
     {
      var active = 1;
      gauge[active].max=gauge_3phs[i].value+ 8;
      gauge[active].angle=270;
      gauge[active].start=180;
      gauge[active].color="'yellow'";
      gauge[active].units="'A'";
      gauge[active].limit=(0);
     }
     else if( i== 2)
     {
      var active = 1; 
      gauge[active].max=(7000);
      gauge[active].limit=(6000);
      gauge[active].units="'W'"
      gauge[active].color="'rgb(' + (pos * 4) + ',' + (255 - (pos * 2)) + ',' + (255 - (pos * 4)) + ')'";
     }
  
   
      const template = passGauge(i);
      document.getElementById('box1').insertAdjacentHTML('beforeend', template);
      console.log(i);

      // Correctly retrieve elements by constructing the IDs dynamically
      var limite = document.getElementById('limite_' + i);
      var point = document.getElementById('point_' + i);
      var valtext = document.getElementById('valtext_' + i);
      var lbltext = document.getElementById('lbltext_' + i);
      var grq = 'g_' + i; 

      gauge[active].value = gauge_1phs[i].value;
      drawG(gauge_1phs[i].value, active, limite, point, valtext, lbltext, grq);

  } catch (error) {
    console.error('Error drawing gauge for index ' + i + ':', error);
  }
}

    break;
  default:

}

var options = {
          series: [{
          data: []
        }],
          chart: {
          type: 'bar',
          height: 320,
          animations: {
        enabled: false,},
        animateGradually: {
            enabled: true,
            delay: 150
        },
        },
        plotOptions: {
          bar: {
            barHeight: '70%',
            distributed: true,
            horizontal: true,
            dataLabels: {
              position: 'bottom'
            },
          }
        },
        colors: ['#00CD8D', '#00FFFF'
        ],
        dataLabels: {
          enabled: true,
          textAnchor: 'start',
          style: {
            fontSize: '25px',
            colors: ['#fff']
          },
          formatter: function (val, opt) {
            return opt.w.globals.labels[opt.dataPointIndex] + ":  " + val +' W'
          },
          offsetX: 0,
          dropShadow: {
            enabled: true
          }
        },
        stroke: {
          width: 1,
          colors: ['#fff']
        },
        xaxis: {
          categories: ['Import', 'Export'
          ],
          labels: {
            show: true,
            style: {
            fontSize:'60px',
            colors: ['white'],
                      },
            
          offsetY: 20,
          },

        },

        yaxis: {
          labels: {
            show: false
          }
        },
        title: {
            text: 'Custom DataLabels',
            align: 'center',
            floating: true
        },
        subtitle: {
            text: 'Category Names as DataLabels inside bars',
            align: 'center',
        },
        tooltip: {
          theme: 'dark',
          x: {
            show: false
          },
          y: {
            title: {
              formatter: function () {
                return ''
              }
            }
          }
        }
        
        };
       
  

for (let x = 0; x < Im_ex.length; x++) {

  var im = Im_ex[x].im;
  var ex = Im_ex[x].ex;
  options.series[0].data = [im, ex]; 
  var chart = new ApexCharts(document.querySelector("#c" + x), options);
  chart.render();
}

}



function popupWin(id)
{
  document.getElementById('popup').style.display='block';
  document.getElementById('overlay').style.display='block';
  id_gg=id;
  display_phs(payload[0]);
}

function display_phs(payload)
{
  var val = 0;  // Default value
    var active = 0;  // Default active gauge index

    // Make sure gauge[active] exists
   
  
    document.getElementById('box2').innerHTML = '';
   var passGauge2 = (i) =>`

  <svg id="ggphs_${i}">
    <g id="gphs_${i}"></g>
    <g id="g2">
      <text id="valtextphs_${i}" class="smooth" x="50%" y="55%" text-anchor="middle" alignment-baseline="bottom"></text>
      <text id="lbltextphs_${i}" class="lbltext" x="50%" y="63%" text-anchor="middle" alignment-baseline="central"></text>
      <circle id="limitephs_${i}" class='limite' cx="50%" cy="50%" />
      <circle id="pointphs_${i}" class="point" cx="50%" cy="50%" />
      <text id="limitTextphs_${i}" x="50%" y="50%" text-anchor="middle" alignment-baseline="central"></text>
    </g>  
  </svg>

`;

for (let i = 0; i < gauge_3phs.length; i++) {

  const template = passGauge2(i);
      document.getElementById('box2').insertAdjacentHTML('beforeend', template);
      console.log(i);

      
      var limite = document.getElementById('limitephs_' + i);
      var point = document.getElementById('pointphs_' + i);
      var valtext = document.getElementById('valtextphs_' + i);
      var lbltext = document.getElementById('lbltextphs_' + i);
      var grq = 'gphs_' + i;  
    
      if(id_gg == 'gg_0')
     {
      var active = 1;
      gauge[active].max=250;
      gauge[active].units="'V'"
      gauge[active].limit=(0);
      gauge[active].angle=360;
      gauge[active].start=270;
      gauge[active].color="'rgb('+(pos*4)+','+(255-(pos*2))+','+(255-(pos*4))+')'";
      var val = payload.volt[i];
      //console.log(val)
      unit.innerHTML='V';
      document.getElementById("v_"+i).innerHTML=val;


      
     }
     else if(id_gg == 'gg_1')
     {
      var active = 1;
      gauge[active].max=50;
      gauge[active].angle=270;
      gauge[active].start=180;
      gauge[active].color="'yellow'";
      gauge[active].units="'A'";
      gauge[active].limit=(0);
      var val = payload.curr[i];
      unit.innerHTML='A';
      document.getElementById("v_"+i).innerHTML=val;
     }
     else if( id_gg == 'gg_2')
     {
      var active = 1; 
      gauge[active].max=(7000);
      gauge[active].limit=(6000);
      gauge[active].units="'W'"
      gauge[active].color="'rgb(' + (pos * 4) + ',' + (255 - (pos * 4)) + ',' + (255 - (pos * 20)) + ')'";
      var val = payload.pow[i];
      unit.innerHTML='W';
    document.getElementById("v_"+i).innerHTML=val;
     } 
      
 
    
      gauge[active].value = val;
      drawG(val, active, limite, point, valtext, lbltext, grq);

  
}


}


function hidePopup() {
    document.getElementById('popup').style.display = 'none';
    document.getElementById('overlay').style.display = 'none';
  }





  connect();


  </script>
</body>
 
</html>